{"version":3,"file":"index.js","sources":["../src/constants/ast.ts","../node_modules/string.fromcodepoint/fromcodepoint.js","../node_modules/unescape-js/dist/index.js","../src/utils.ts","../src/jsObject/index.ts","../src/index.ts"],"sourcesContent":["export const ECMA_VERSION = 11;\n\n/* Indicates the mode the code should be parsed in. \nThis influences global strict mode and parsing of import and export declarations.\n*/\nexport enum SourceType {\n  script = 'script',\n  module = 'module',\n}\n\n// Each node has an attached type property which further defines\n// what all properties can the node have.\n// We will just define the ones we are working with\nexport enum NodeTypes {\n  Identifier = 'Identifier',\n  AssignmentPattern = 'AssignmentPattern',\n  Literal = 'Literal',\n  Property = 'Property',\n  // Declaration - https://github.com/estree/estree/blob/master/es5.md#declarations\n  FunctionDeclaration = 'FunctionDeclaration',\n  ExportDefaultDeclaration = 'ExportDefaultDeclaration',\n  VariableDeclarator = 'VariableDeclarator',\n  // Expression - https://github.com/estree/estree/blob/master/es5.md#expressions\n  MemberExpression = 'MemberExpression',\n  FunctionExpression = 'FunctionExpression',\n  ArrowFunctionExpression = 'ArrowFunctionExpression',\n  ObjectExpression = 'ObjectExpression',\n  ArrayExpression = 'ArrayExpression',\n  ThisExpression = 'ThisExpression',\n}\n","/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"string.fromcodepoint\");\n\n/**\n * \\\\ - matches the backslash which indicates the beginning of an escape sequence\n * (\n *   u\\{([0-9A-Fa-f]+)\\} - first alternative; matches the variable-length hexadecimal escape sequence (\\u{ABCD0})\n * |\n *   u([0-9A-Fa-f]{4}) - second alternative; matches the 4-digit hexadecimal escape sequence (\\uABCD)\n * |\n *   x([0-9A-Fa-f]{2}) - third alternative; matches the 2-digit hexadecimal escape sequence (\\xA5)\n * |\n *   ([1-7][0-7]{0,2}|[0-7]{2,3}) - fourth alternative; matches the up-to-3-digit octal escape sequence (\\5 or \\512)\n * |\n *   (['\"tbrnfv0\\\\]) - fifth alternative; matches the special escape characters (\\t, \\n and so on)\n * |\n *   \\U([0-9A-Fa-f]+) - sixth alternative; matches the 8-digit hexadecimal escape sequence used by python (\\U0001F3B5)\n * )\n */\nvar jsEscapeRegex = /\\\\(u\\{([0-9A-Fa-f]+)\\}|u([0-9A-Fa-f]{4})|x([0-9A-Fa-f]{2})|([1-7][0-7]{0,2}|[0-7]{2,3})|(['\"tbrnfv0\\\\]))|\\\\U([0-9A-Fa-f]{8})/g;\nvar usualEscapeSequences = {\n  '0': '\\0',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\'\n};\n\nvar fromHex = function fromHex(str) {\n  return String.fromCodePoint(parseInt(str, 16));\n};\n\nvar fromOct = function fromOct(str) {\n  return String.fromCodePoint(parseInt(str, 8));\n};\n\nvar _default = function _default(string) {\n  return string.replace(jsEscapeRegex, function (_, __, varHex, longHex, shortHex, octal, specialCharacter, python) {\n    if (varHex !== undefined) {\n      return fromHex(varHex);\n    } else if (longHex !== undefined) {\n      return fromHex(longHex);\n    } else if (shortHex !== undefined) {\n      return fromHex(shortHex);\n    } else if (octal !== undefined) {\n      return fromOct(octal);\n    } else if (python !== undefined) {\n      return fromHex(python);\n    } else {\n      return usualEscapeSequences[specialCharacter];\n    }\n  });\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","import unescapeJS from 'unescape-js';\n\nconst beginsWithLineBreakRegex = /^\\s+|\\s+$/;\n\nexport function sanitizeScript(js: string, evaluationVersion: number) {\n  // We remove any line breaks from the beginning of the script because that\n  // makes the final function invalid. We also unescape any escaped characters\n  // so that eval can happen\n  //default value of evalutaion version is 2\n  evaluationVersion = evaluationVersion ? evaluationVersion : 2;\n  const trimmedJS = js.replace(beginsWithLineBreakRegex, '');\n  return evaluationVersion > 1 ? trimmedJS : unescapeJS(trimmedJS);\n}\n\n// For the times when you need to know if something truly an object like { a: 1, b: 2}\n// typeof, lodash.isObject and others will return false positives for things like array, null, etc\nexport const isTrueObject = (\n  item: unknown\n): item is Record<string, unknown> => {\n  return Object.prototype.toString.call(item) === '[object Object]';\n};\n","import { Node } from \"acorn\";\nimport { getAST } from \"../index\";\nimport { generate } from \"astring\";\nimport { simple } from \"acorn-walk\";\nimport {\n  getFunctionalParamsFromNode,\n  isPropertyAFunctionNode,\n  isVariableDeclarator,\n  isObjectExpression,\n  PropertyNode,\n  functionParam,\n} from \"../index\";\n\ntype JsObjectProperty = {\n  key: string;\n  value: string;\n  type: string;\n  arguments?: Array<functionParam>;\n};\n\nconst jsObjectVariableName =\n  \"____INTERNAL_JS_OBJECT_NAME_USED_FOR_PARSING_____\";\n\nexport const jsObjectDeclaration = `var ${jsObjectVariableName} =`;\n\nexport const parseJSObjectWithAST = (\n  jsObjectBody: string\n): Array<JsObjectProperty> => {\n  /* \n      jsObjectVariableName value is added such actual js code would never name same variable name. \n      if the variable name will be same then also we won't have problem here as jsObjectVariableName will be last node in VariableDeclarator hence overriding the previous JSObjectProperties.\n      Keeping this just for sanity check if any caveat was missed.\n    */\n  const jsCode = `${jsObjectDeclaration} ${jsObjectBody}`;\n\n  const ast = getAST(jsCode);\n\n  const parsedObjectProperties = new Set<JsObjectProperty>();\n  let JSObjectProperties: Array<PropertyNode> = [];\n\n  simple(ast, {\n    VariableDeclarator(node: Node) {\n      if (\n        isVariableDeclarator(node) &&\n        node.id.name === jsObjectVariableName &&\n        node.init &&\n        isObjectExpression(node.init)\n      ) {\n        JSObjectProperties = node.init.properties;\n      }\n    },\n  });\n\n  JSObjectProperties.forEach((node) => {\n    let params = new Set<functionParam>();\n    const propertyNode = node;\n    let property: JsObjectProperty = {\n      key: generate(propertyNode.key),\n      value: generate(propertyNode.value),\n      type: propertyNode.value.type,\n    };\n\n    if (isPropertyAFunctionNode(propertyNode.value)) {\n      // if in future we need default values of each param, we could implement that in getFunctionalParamsFromNode\n      // currently we don't consume it anywhere hence avoiding to calculate that.\n      params = getFunctionalParamsFromNode(propertyNode.value);\n      property = {\n        ...property,\n        arguments: [...params],\n      };\n    }\n\n    // here we use `generate` function to convert our AST Node to JSCode\n    parsedObjectProperties.add(property);\n  });\n\n  return [...parsedObjectProperties];\n};\n","import { parse, Node, SourceLocation, Options, Comment } from \"acorn\";\nimport { ancestor, simple } from \"acorn-walk\";\nimport { ECMA_VERSION, NodeTypes } from \"./constants/ast\";\nimport { has, isFinite, isString, memoize, toPath } from \"lodash\";\nimport { isTrueObject, sanitizeScript } from \"./utils\";\nimport { jsObjectDeclaration } from \"./jsObject/index\";\n/*\n * Valuable links:\n *\n * * ESTree spec: Javascript AST is called ESTree.\n * Each es version has its md file in the repo to find features\n * implemented and their node type\n * https://github.com/estree/estree\n *\n * * Acorn: The parser we use to get the AST\n * https://github.com/acornjs/acorn\n *\n * * Acorn walk: The walker we use to traverse the AST\n * https://github.com/acornjs/acorn/tree/master/acorn-walk\n *\n * * AST Explorer: Helpful web tool to see ASTs and its parts\n * https://astexplorer.net/\n *\n */\n\ntype Pattern = IdentifierNode | AssignmentPatternNode;\ntype Expression = Node;\n// doc: https://github.com/estree/estree/blob/master/es5.md#memberexpression\ninterface MemberExpressionNode extends Node {\n  type: NodeTypes.MemberExpression;\n  object: MemberExpressionNode | IdentifierNode;\n  property: IdentifierNode | LiteralNode;\n  computed: boolean;\n  // doc: https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n  optional?: boolean;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#identifier\ninterface IdentifierNode extends Node {\n  type: NodeTypes.Identifier;\n  name: string;\n}\n\n//Using this to handle the Variable property refactor\ninterface RefactorIdentifierNode extends Node {\n  type: NodeTypes.Identifier;\n  name: string;\n  property?: IdentifierNode;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#variabledeclarator\ninterface VariableDeclaratorNode extends Node {\n  type: NodeTypes.VariableDeclarator;\n  id: IdentifierNode;\n  init: Expression | null;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functions\ninterface Function extends Node {\n  id: IdentifierNode | null;\n  params: Pattern[];\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functiondeclaration\ninterface FunctionDeclarationNode extends Node, Function {\n  type: NodeTypes.FunctionDeclaration;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functionexpression\ninterface FunctionExpressionNode extends Expression, Function {\n  type: NodeTypes.FunctionExpression;\n}\n\ninterface ArrowFunctionExpressionNode extends Expression, Function {\n  type: NodeTypes.ArrowFunctionExpression;\n}\n\nexport interface ObjectExpression extends Expression {\n  type: NodeTypes.ObjectExpression;\n  properties: Array<PropertyNode>;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es2015.md#assignmentpattern\ninterface AssignmentPatternNode extends Node {\n  type: NodeTypes.AssignmentPattern;\n  left: Pattern;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#literal\ninterface LiteralNode extends Node {\n  type: NodeTypes.Literal;\n  value: string | boolean | null | number | RegExp;\n}\n\ntype NodeList = {\n  references: Set<string>;\n  functionalParams: Set<string>;\n  variableDeclarations: Set<string>;\n  identifierList: Array<IdentifierNode>;\n};\n\n// https://github.com/estree/estree/blob/master/es5.md#property\nexport interface PropertyNode extends Node {\n  type: NodeTypes.Property;\n  key: LiteralNode | IdentifierNode;\n  value: Node;\n  kind: \"init\" | \"get\" | \"set\";\n}\n\n// Node with location details\ntype NodeWithLocation<NodeType> = NodeType & {\n  loc: SourceLocation;\n};\n\ntype AstOptions = Omit<Options, \"ecmaVersion\">;\n\ntype EntityRefactorResponse = {\n  isSuccess: boolean;\n  body: { script: string; refactorCount: number } | { error: string };\n};\n\n/* We need these functions to typescript casts the nodes with the correct types */\nexport const isIdentifierNode = (node: Node): node is IdentifierNode => {\n  return node.type === NodeTypes.Identifier;\n};\n\nconst isMemberExpressionNode = (node: Node): node is MemberExpressionNode => {\n  return node.type === NodeTypes.MemberExpression;\n};\n\nexport const isVariableDeclarator = (\n  node: Node,\n): node is VariableDeclaratorNode => {\n  return node.type === NodeTypes.VariableDeclarator;\n};\n\nconst isFunctionDeclaration = (node: Node): node is FunctionDeclarationNode => {\n  return node.type === NodeTypes.FunctionDeclaration;\n};\n\nconst isFunctionExpression = (node: Node): node is FunctionExpressionNode => {\n  return node.type === NodeTypes.FunctionExpression;\n};\nconst isArrowFunctionExpression = (\n  node: Node,\n): node is ArrowFunctionExpressionNode => {\n  return node.type === NodeTypes.ArrowFunctionExpression;\n};\n\nexport const isObjectExpression = (node: Node): node is ObjectExpression => {\n  return node.type === NodeTypes.ObjectExpression;\n};\n\nconst isAssignmentPatternNode = (node: Node): node is AssignmentPatternNode => {\n  return node.type === NodeTypes.AssignmentPattern;\n};\n\nexport const isLiteralNode = (node: Node): node is LiteralNode => {\n  return node.type === NodeTypes.Literal;\n};\n\nexport const isPropertyNode = (node: Node): node is PropertyNode => {\n  return node.type === NodeTypes.Property;\n};\n\nexport const isPropertyAFunctionNode = (\n  node: Node,\n): node is ArrowFunctionExpressionNode | FunctionExpressionNode => {\n  return (\n    node.type === NodeTypes.ArrowFunctionExpression ||\n    node.type === NodeTypes.FunctionExpression\n  );\n};\n\nconst isArrayAccessorNode = (node: Node): node is MemberExpressionNode => {\n  return (\n    isMemberExpressionNode(node) &&\n    node.computed &&\n    isLiteralNode(node.property) &&\n    isFinite(node.property.value)\n  );\n};\n\nconst wrapCode = (code: string) => {\n  return `\n    (function() {\n      return ${code}\n    })\n  `;\n};\n\n//Tech-debt: should upgrade this to better logic\n//Used slice for a quick resolve of critical bug\nconst unwrapCode = (code: string) => {\n  let unwrapedCode = code.slice(32);\n  return unwrapedCode.slice(0, -10);\n};\n\nconst getFunctionalParamNamesFromNode = (\n  node:\n    | FunctionDeclarationNode\n    | FunctionExpressionNode\n    | ArrowFunctionExpressionNode,\n) => {\n  return Array.from(getFunctionalParamsFromNode(node)).map(\n    (functionalParam) => functionalParam.paramName,\n  );\n};\n\n// Memoize the ast generation code to improve performance.\n// Since this will be used by both the server and the client, we want to prevent regeneration of ast\n// for the the same code snippet\nexport const getAST = memoize((code: string, options?: AstOptions) =>\n  parse(code, { ...options, ecmaVersion: ECMA_VERSION }),\n);\n\n/**\n * An AST based extractor that fetches all possible references in a given\n * piece of code. We use this to get any references to the global entities in Appsmith\n * and create dependencies on them. If the reference was updated, the given piece of code\n * should run again.\n * @param code: The piece of script where references need to be extracted from\n */\n\nexport interface IdentifierInfo {\n  references: string[];\n  functionalParams: string[];\n  variables: string[];\n}\nexport const extractIdentifierInfoFromCode = (\n  code: string,\n  evaluationVersion: number,\n  invalidIdentifiers?: Record<string, unknown>,\n): IdentifierInfo => {\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  try {\n    const sanitizedScript = sanitizeScript(code, evaluationVersion);\n    /* wrapCode - Wrapping code in a function, since all code/script get wrapped with a function during evaluation.\n       Some syntax won't be valid unless they're at the RHS of a statement.\n       Since we're assigning all code/script to RHS during evaluation, we do the same here.\n       So that during ast parse, those errors are neglected.\n    */\n    /* e.g. IIFE without braces\n      function() { return 123; }() -> is invalid\n      let result = function() { return 123; }() -> is valid\n    */\n    const wrappedCode = wrapCode(sanitizedScript);\n    ast = getAST(wrappedCode);\n    let { references, functionalParams, variableDeclarations }: NodeList =\n      ancestorWalk(ast);\n    const referencesArr = Array.from(references).filter((reference) => {\n      // To remove references derived from declared variables and function params,\n      // We extract the topLevelIdentifier Eg. Api1.name => Api1\n      const topLevelIdentifier = toPath(reference)[0];\n      return !(\n        functionalParams.has(topLevelIdentifier) ||\n        variableDeclarations.has(topLevelIdentifier) ||\n        has(invalidIdentifiers, topLevelIdentifier)\n      );\n    });\n    return {\n      references: referencesArr,\n      functionalParams: Array.from(functionalParams),\n      variables: Array.from(variableDeclarations),\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return {\n        references: [],\n        functionalParams: [],\n        variables: [],\n      };\n    }\n    throw e;\n  }\n};\n\nexport const entityRefactorFromCode = (\n  script: string,\n  oldName: string,\n  newName: string,\n  isJSObject: boolean,\n  evaluationVersion: number,\n  invalidIdentifiers?: Record<string, unknown>,\n): EntityRefactorResponse => {\n  //Sanitizing leads to removal of special charater.\n  //Hence we are not sanatizing the script. Fix(#18492)\n  //If script is a JSObject then replace export default to decalartion.\n  if (isJSObject) script = jsObjectToCode(script);\n  else script = wrapCode(script);\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  //Copy of script to refactor\n  let refactorScript = script;\n  //Difference in length of oldName and newName\n  const nameLengthDiff: number = newName.length - oldName.length;\n  //Offset index used for deciding location of oldName.\n  let refactorOffset: number = 0;\n  //Count of refactors on the script\n  let refactorCount: number = 0;\n  try {\n    ast = getAST(script);\n    let {\n      references,\n      functionalParams,\n      variableDeclarations,\n      identifierList,\n    }: NodeList = ancestorWalk(ast);\n    const identifierArray = Array.from(\n      identifierList,\n    ) as Array<RefactorIdentifierNode>;\n    //To handle if oldName has property (\"JSObject.myfunc\")\n    const oldNameArr = oldName.split(\".\");\n    const referencesArr = Array.from(references).filter((reference) => {\n      // To remove references derived from declared variables and function params,\n      // We extract the topLevelIdentifier Eg. Api1.name => Api1\n      const topLevelIdentifier = toPath(reference)[0];\n      return !(\n        functionalParams.has(topLevelIdentifier) ||\n        variableDeclarations.has(topLevelIdentifier) ||\n        has(invalidIdentifiers, topLevelIdentifier)\n      );\n    });\n    //Traverse through all identifiers in the script\n    identifierArray.forEach((identifier) => {\n      if (identifier.name === oldNameArr[0]) {\n        let index = 0;\n        while (index < referencesArr.length) {\n          if (identifier.name === referencesArr[index].split(\".\")[0]) {\n            //Replace the oldName by newName\n            //Get start index from node and get subarray from index 0 till start\n            //Append above with new name\n            //Append substring from end index from the node till end of string\n            //Offset variable is used to alter the position based on `refactorOffset`\n            //In case of nested JS action get end postion fro the property.\n            ///Default end index\n            let endIndex = identifier.end;\n            const propertyNode = identifier.property;\n            //Flag variable : true if property should be updated\n            //false if property should not be updated\n            let propertyCondFlag =\n              oldNameArr.length > 1 &&\n              propertyNode &&\n              oldNameArr[1] === propertyNode.name;\n            //Condition to validate if Identifier || Property should be updated??\n            if (oldNameArr.length === 1 || propertyCondFlag) {\n              //Condition to extend end index in case of property match\n              if (propertyCondFlag && propertyNode) {\n                endIndex = propertyNode.end;\n              }\n              refactorScript =\n                refactorScript.substring(0, identifier.start + refactorOffset) +\n                newName +\n                refactorScript.substring(endIndex + refactorOffset);\n              refactorOffset += nameLengthDiff;\n              ++refactorCount;\n              //We are only looking for one match in refrence for the identifier name.\n              break;\n            }\n          }\n          index++;\n        }\n      }\n    });\n    //If script is a JSObject then revert decalartion to export default.\n    if (isJSObject) refactorScript = jsCodeToObject(refactorScript);\n    else refactorScript = unwrapCode(refactorScript);\n    return {\n      isSuccess: true,\n      body: { script: refactorScript, refactorCount },\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return { isSuccess: false, body: { error: \"Syntax Error\" } };\n    }\n    throw e;\n  }\n};\n\nexport type functionParam = { paramName: string; defaultValue: unknown };\n\nexport const getFunctionalParamsFromNode = (\n  node:\n    | FunctionDeclarationNode\n    | FunctionExpressionNode\n    | ArrowFunctionExpressionNode,\n  needValue = false,\n): Set<functionParam> => {\n  const functionalParams = new Set<functionParam>();\n  node.params.forEach((paramNode) => {\n    if (isIdentifierNode(paramNode)) {\n      functionalParams.add({\n        paramName: paramNode.name,\n        defaultValue: undefined,\n      });\n    } else if (isAssignmentPatternNode(paramNode)) {\n      if (isIdentifierNode(paramNode.left)) {\n        const paramName = paramNode.left.name;\n        if (!needValue) {\n          functionalParams.add({ paramName, defaultValue: undefined });\n        } else {\n          // figure out how to get value of paramNode.right for each node type\n          // currently we don't use params value, hence skipping it\n          // functionalParams.add({\n          //   defaultValue: paramNode.right.value,\n          // });\n        }\n      }\n    }\n  });\n  return functionalParams;\n};\n\nconst constructFinalMemberExpIdentifier = (\n  node: MemberExpressionNode,\n  child = \"\",\n): string => {\n  const propertyAccessor = getPropertyAccessor(node.property);\n  if (isIdentifierNode(node.object)) {\n    return `${node.object.name}${propertyAccessor}${child}`;\n  } else {\n    const propertyAccessor = getPropertyAccessor(node.property);\n    const nestedChild = `${propertyAccessor}${child}`;\n    return constructFinalMemberExpIdentifier(node.object, nestedChild);\n  }\n};\n\nconst getPropertyAccessor = (propertyNode: IdentifierNode | LiteralNode) => {\n  if (isIdentifierNode(propertyNode)) {\n    return `.${propertyNode.name}`;\n  } else if (isLiteralNode(propertyNode) && isString(propertyNode.value)) {\n    // is string literal search a['b']\n    return `.${propertyNode.value}`;\n  } else if (isLiteralNode(propertyNode) && isFinite(propertyNode.value)) {\n    // is array index search - a[9]\n    return `[${propertyNode.value}]`;\n  }\n};\n\nexport const isTypeOfFunction = (type: string) => {\n  return (\n    type === NodeTypes.ArrowFunctionExpression ||\n    type === NodeTypes.FunctionExpression\n  );\n};\n\nexport interface MemberExpressionData {\n  property: NodeWithLocation<IdentifierNode | LiteralNode>;\n  object: NodeWithLocation<IdentifierNode>;\n}\n\n/** Function returns Invalid top-level member expressions from code\n * @param code\n * @param data\n * @param evaluationVersion\n * @returns information about all invalid property/method assessment in code\n * @example Given data {\n * JSObject1: {\n * name:\"JSObject\",\n * data:[]\n * },\n * Api1:{\n * name: \"Api1\",\n * data: []\n * }\n * },\n * For code {{Api1.name + JSObject.unknownProperty}}, function returns information about \"JSObject.unknownProperty\" node.\n */\nexport const extractInvalidTopLevelMemberExpressionsFromCode = (\n  code: string,\n  data: Record<string, any>,\n  evaluationVersion: number,\n): MemberExpressionData[] => {\n  const invalidTopLevelMemberExpressions = new Set<MemberExpressionData>();\n  const variableDeclarations = new Set<string>();\n  let functionalParams = new Set<string>();\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  try {\n    const sanitizedScript = sanitizeScript(code, evaluationVersion);\n    const wrappedCode = wrapCode(sanitizedScript);\n    ast = getAST(wrappedCode, { locations: true });\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return [];\n    }\n    throw e;\n  }\n  simple(ast, {\n    MemberExpression(node: Node) {\n      const { object, property, computed } = node as MemberExpressionNode;\n      // We are only interested in top-level MemberExpression nodes\n      // Eg. for Api1.data.name, we are only interested in Api1.data\n      if (!isIdentifierNode(object)) return;\n      if (!(object.name in data) || !isTrueObject(data[object.name])) return;\n      // For computed member expressions (assessed via [], eg. JSObject1[\"name\"] ),\n      // We are only interested in strings\n      if (\n        isLiteralNode(property) &&\n        isString(property.value) &&\n        !(property.value in data[object.name])\n      ) {\n        invalidTopLevelMemberExpressions.add({\n          object,\n          property,\n        } as MemberExpressionData);\n      }\n      // We ignore computed member expressions if property is an identifier (JSObject[name])\n      // This is because we can't statically determine what the value of the identifier might be.\n      if (\n        isIdentifierNode(property) &&\n        !computed &&\n        !(property.name in data[object.name])\n      ) {\n        invalidTopLevelMemberExpressions.add({\n          object,\n          property,\n        } as MemberExpressionData);\n      }\n    },\n    VariableDeclarator(node: Node) {\n      if (isVariableDeclarator(node)) {\n        variableDeclarations.add(node.id.name);\n      }\n    },\n    FunctionDeclaration(node: Node) {\n      if (!isFunctionDeclaration(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    FunctionExpression(node: Node) {\n      if (!isFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    ArrowFunctionExpression(node: Node) {\n      if (!isArrowFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n  });\n\n  const invalidTopLevelMemberExpressionsArray = Array.from(\n    invalidTopLevelMemberExpressions,\n  ).filter((MemberExpression) => {\n    return !(\n      variableDeclarations.has(MemberExpression.object.name) ||\n      functionalParams.has(MemberExpression.object.name)\n    );\n  });\n\n  return invalidTopLevelMemberExpressionsArray;\n};\n\nconst ancestorWalk = (ast: Node): NodeList => {\n  //List of all Identifier nodes with their property(if exists).\n  const identifierList = new Array<RefactorIdentifierNode>();\n  // List of all references found\n  const references = new Set<string>();\n  // List of variables declared within the script. All identifiers and member expressions derived from declared variables will be removed\n  const variableDeclarations = new Set<string>();\n  // List of functional params declared within the script. All identifiers and member expressions derived from functional params will be removed\n  let functionalParams = new Set<string>();\n\n  /*\n   * We do an ancestor walk on the AST in order to extract all references. For example, for member expressions and identifiers, we need to know\n   * what surrounds the identifier (its parent and ancestors), ancestor walk will give that information in the callback\n   * doc: https://github.com/acornjs/acorn/tree/master/acorn-walk\n   */\n  ancestor(ast, {\n    Identifier(node: Node, ancestors: Node[]) {\n      /*\n       * We are interested in identifiers. Due to the nature of AST, Identifier nodes can\n       * also be nested inside MemberExpressions. For deeply nested object references, there\n       * could be nesting of many MemberExpressions. To find the final reference, we will\n       * try to find the top level MemberExpression that does not have a MemberExpression parent.\n       * */\n      let candidateTopLevelNode: IdentifierNode | MemberExpressionNode =\n        node as IdentifierNode;\n      let depth = ancestors.length - 2; // start \"depth\" with first parent\n      while (depth > 0) {\n        const parent = ancestors[depth];\n        if (\n          isMemberExpressionNode(parent) &&\n          /* Member expressions that are \"computed\" (with [ ] search)\n             and the ones that have optional chaining ( a.b?.c )\n             will be considered top level node.\n             We will stop looking for further parents */\n          /* \"computed\" exception - isArrayAccessorNode\n             Member expressions that are array accessors with static index - [9]\n             will not be considered top level.\n             We will continue looking further. */\n          (!parent.computed || isArrayAccessorNode(parent)) &&\n          !parent.optional\n        ) {\n          candidateTopLevelNode = parent;\n          depth = depth - 1;\n        } else {\n          // Top level found\n          break;\n        }\n      }\n      //If parent is a Member expression then attach property to the Node.\n      //else push Identifier Node.\n      const parentNode = ancestors[ancestors.length - 2];\n      if (isMemberExpressionNode(parentNode)) {\n        identifierList.push({\n          ...(node as IdentifierNode),\n          property: parentNode.property as IdentifierNode,\n        });\n      } else identifierList.push(node as RefactorIdentifierNode);\n      if (isIdentifierNode(candidateTopLevelNode)) {\n        // If the node is an Identifier, just save that\n        references.add(candidateTopLevelNode.name);\n      } else {\n        // For MemberExpression Nodes, we will construct a final reference string and then add\n        // it to the references list\n        const memberExpIdentifier = constructFinalMemberExpIdentifier(\n          candidateTopLevelNode,\n        );\n        references.add(memberExpIdentifier);\n      }\n    },\n    VariableDeclarator(node: Node) {\n      // keep a track of declared variables so they can be\n      // removed from the final list of references\n      if (isVariableDeclarator(node)) {\n        variableDeclarations.add(node.id.name);\n      }\n    },\n    FunctionDeclaration(node: Node) {\n      // params in function declarations are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isFunctionDeclaration(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    FunctionExpression(node: Node) {\n      // params in function expressions are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    ArrowFunctionExpression(node: Node) {\n      // params in arrow function expressions are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isArrowFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n  });\n  return {\n    references,\n    functionalParams,\n    variableDeclarations,\n    identifierList,\n  };\n};\n\n//Replace export default by a variable declaration.\n//This is required for acorn to parse code into AST.\nconst jsObjectToCode = (script: string) => {\n  return script.replace(/export default/g, jsObjectDeclaration);\n};\n\n//Revert the string replacement from 'jsObjectToCode'.\n//variable declaration is replaced back by export default.\nconst jsCodeToObject = (script: string) => {\n  return script.replace(jsObjectDeclaration, \"export default\");\n};\n"],"names":["SourceType","NodeTypes","simple","generate","isFinite","memoize","parse","toPath","has","isString","ancestor"],"mappings":"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"}